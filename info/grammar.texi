@node Grammar
@appendix @acronym{CREOL} Grammar

For reference, we summarise the grammar of @acronym{CREOL}.  The grammar of
@acronym{CREOL} is LR(1) and is used by the compiler.  @code{@{...@}} means a
list of symbols, where the optional decorator at the end indicates the
separator.  An optional symbol is enclosed in square brackets like
this: @code{[ ... ]}.  Terminal symbols are printed like this:
@strong{terminal}.  Finally, the symbol @var{id}, denoting method
names, functions, and variables, refers to an identifier, which is any
string that matches the regular expression @code{[_a-z][_'0-9A-Za-z]*},
and @var{cid}, denoting class and type names, refers to any string
that matches the regular expression @code{[A-Z][_0-9A-Za-z]*}.


@section Reserved Keywords
@anchor{Keywords}

The following are reserved as keywords and cannot be used for
variable or method names in programs.

@c 45678901 34567890123 56789012345 78901234567 90123456789 12345678901
@example
as          assert      await       begin       caller      class
contracts   datatype    do          else        end         ensures
exists      external    false       forall      function    history
if          implements  in          inherits    interface   inv
method      new         nil         now         null        of
op          out         posit       prove       release     requires
skip        some        then        this        true        var
while       with
@end example

Currently reserved, but unused keywords are
@example
by          case        component   constant    exception   exports
for         from        imports     is          measure     object
pragma      provides    signal      throw       throws      try
volatile    when        where
@end example

The following symbols are used as operator symbols.  They are listed
in the order of their precedence.  Operators on any line bind stronger
than ones on the lines above.

@example
,                               @r{left}
|                               @r{left}
in                              @r{left}
<=>                             @r{left}
=>                              @r{left}
^                               @r{left}
|| \/                           @r{left}
&& /\                           @r{left}
~                               @r{right, unary operator}
= /=                            @r{non-associative}
<= < > >=                       @r{non-associative}
\                               @r{left}
|-|                             @r{left}
-|                              @r{right}
|-                              @r{left}
+ -                             @r{left}
* / %                           @r{left}
**                              @r{left}
- #                             @r{right, unary operators}
@end example


@section Grammar

The grammar specified in this section is in LR(1) and does not contain
any shift-reduce or reduce-reduce conflicts.  This means, that each
syntactically correct @acronym{CREOL} program has a unique parse tree.

@format
main ::=
    @{ declaration @}

declaration ::= class-decl | interface-decl | datatype-decl | function-def

class-decl ::=
    @strong{class} cid
    [ @strong{(} @{ var-decl-no-init @strong{,} @} @strong{)}]@c
    @{ (@strong{contracts} | @strong{implements} | @strong{inherits} )@c
    @{ cid plist @strong{,} @} @}
    @{ pragma @} @strong{begin} @{ @strong{var} var-decl [ @strong{;} ] @}@c
    [ anon-with-def ] @{ with-def @}@c
    @strong{end}

interface-decl ::=
    @strong{interface} id [ @strong{(} @{ var-decl-no-init @strong{,} @} @strong{)}]@c
    @{ @strong{inherits} @{ id @strong{,} @} @} @{ pragma @}
    @strong{begin} @{ invariant @} @{ @strong{with} cid @{ op-decl @} @{ invariant @} @} @strong{end}

datatype-decl ::=
    @strong{datatype} type [ @strong{from} @{ type @strong{,} @} ] @{ pragma @}

function-def ::=
    @strong{function} id-or-op @strong{(} @{ var-decl-no-init @strong{,} @} @strong{)} @strong{:} type @{ pragma @} @strong{==} ( expr | @strong{external} string )

var-decl-no-init ::=
    @{ id @strong{,} @} @strong{:} type

var-decl ::=
    var-decl-no-init @strong{:=} @{ expr-or-new @strong{,} @}

op-decl ::=
    @strong{op} id @strong{(} [ [ @strong{in} ] @{ var-decl-no-init @strong{,} @} ] [ [ @strong{;} ] @strong{out} @{ var-decl-no-init @strong{,} @} ] @strong{)}
    [@strong{requires} expr] [@strong{ensures} expr] @{ pragma @}

anon-with-def ::=
    @{ op-def @} @{ invariant @}

with-def ::=
    @strong{with} cid @{ op-def @} @{ invariant @}

op-def ::=
    op-decl @strong{==} @{ @strong{var} var-decl @strong{;} @} ( statement | @strong{external} string )

statement ::=
    choice-statement [ @strong{|||} statement ]

choice-statement ::=
    seq-statement [ @strong{[]} choice-statement ]

seq-statement ::=
    basic-statement [ @strong{;} seq-statement ]

basic-statement ::=
    @strong{skip}
  | @{ lhs @strong{,} @} @strong{:=} @{ expr-or-new @strong{,} @}
  | @strong{release}
  | @strong{await} expr
  | @strong{posit} expr
  | id @strong{?} @strong{(}  @{ lhs @strong{,} @} @strong{)}
  | [ id ] @strong{!} expr @strong{.} id @strong{(} @{ expr @strong{,} @} @strong{)} [ @strong{as} type ]
  | [ id ] @strong{!} id bounds @strong{(} @{ expr @strong{,} @} @strong{)}
  | [ @strong{await} ] expr @strong{.} id @strong{(} @{ expr @strong{,} @} @strong{;} @{ lhs @strong{,} @} @strong{)} [ @strong{as} type ]
  | [ @strong{await} ] id bounds @strong{(} @{ expr @strong{,} @} @strong{;} @{ lhs @strong{,} @} @strong{)}
  | @strong{begin} statement @strong{end}
  | @strong{if} expr @strong{then} statement [@strong{else} statement] @strong{end}
  | @strong{while} expr [ @strong{inv} expr ] @strong{do} statement @strong{end}
  | @strong{do} statement [ @strong{inv} expr ] @strong{while} expr
  | @strong{assert} expr
  | @strong{prove} expr

bounds ::=
    empty | @strong{:>} cid | @strong{<:} cid | @strong{:>} cid @strong{<:} cid | @strong{<:} cid @strong{:>} cid

lhs ::=
    id [ @strong{@@} type ]
  | @strong{_} [ @strong{as} type ]

expr-or-new ::=
    @strong{new} cid plist
  | expr

expr ::=
    @strong{true} | @strong{false} | integer | float | string @c
  | @strong{this} | @strong{caller} | @strong{nil} | @strong{null} @c
  | id [ (@strong{?} | @strong{@@} type) ]
  | @strong{(} @{ expr @strong{,} @} @strong{)}
  | @strong{[} @{ expr @strong{,} @} @strong{]}
  | @strong{@{} @{ expr @strong{,} @} @strong{@}}
  | @strong{@{} id @strong{:} type @strong{|} expr @strong{@}}
  | unaryop expr | expr binop expr | id @strong{(} @{ expr @strong{,} @} @strong{)}
  | @strong{if} expr @strong{then} expr @strong{else} expr @strong{end}
  | @strong{(} (@strong{forall} | @strong{exists} | @strong{some}) var-decl-no-init @strong{:} expr @strong{)}

unaryop ::=
    @strong{~} | @strong{-} | @strong{#}

binop ::=
    @strong{&&} | @strong{/\} | @strong{||} | @strong{\/} | @strong{^} @c
  | @strong{<=>} | @strong{=>} @c
  | @strong{=} | @strong{/=} | @strong{<} | @strong{>} | @strong{<=} | @strong{>=}
  | @strong{+} | @strong{-} | @strong{*} | @strong{**} | @strong{/} | @strong{%} @c
  | @strong{-|} | @strong{|-|} | @strong{|-} | @strong{\} | @strong{in}

id-or-op ::=
    unaryop | binaryop | id

plist ::=
    [ @strong{(} @{ expr @strong{,} @strong{)} ]

type ::=
    cid [ @strong{[} @{ type , @} @strong{]} ]
  | @strong{[} @{ type , @} @strong{]}
  | @strong{`} id

pragma ::=
    @strong{pragma} cid plist
@end format
