dnl A simple term replacement system for Creol.
dnl
dnl Copyright (c) 2009 by Andreas Griesmayer <gismo@kangaroo.at>
dnl   and Marcel Kyas <kyas@ifi.uio.no>
dnl
dnl Do NOT edit this file.  This file may be overwritten.  It has been
dnl automatically generated from interpreter.m4 using m4.
dnl
dnl This program is free software; you can redistribute it and/or
dnl modify it under the terms of the GNU General Public License as
dnl published by the Free Software Foundation; either version 3 of the
dnl License, or (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl General Public License for more details.
dnl
dnl You should have received a copy of the GNU General Public License
dnl along with this program.  If not, see <http://www.gnu.org/licenses/>.
dnl
mod `CREOL-RENAME' is

    protecting CREOL-REPLACE .

------------------------------------------------------------------------
--- give variables a unique name
--- --------------------------------------------------------------------
--- The log is a serialized version of Creol.  Statements from
--- different methods and objects are interleaved and might operate on
--- variables that are actually different`,' but have the same name.  To
--- avoid the necessity to consider the scope at the execution of
--- every statement`,' the variables are renamed to a unique name`,' by
--- prefixim them with an identifyer.  The object ID is used for
--- global variables`,' and the label for local variables.

    vars TS1 TS2 : TSubst .
    var V1 : Vid .
    var S L : Subst .
    var Q A : String . 
    vars E1 E2 : Expr .
    var F : Nat .
    var O : Oid .
    var AL : VidList .
    var EL : ExprList .


--- examples
--- EXAMPLE rew renameLHS ( ( "s" |-> int(4), "d" |-> int(4) ) , "pre", ( "s" |> "sd", "ff" |> "fs") ) .
--- example rew renameRHS( genRenameHelper( ("sd" |-> int(0) ), "pre" ) , ( "s" |> "+"( "sd" :: int(2) ), "ff" |> "fs") ) .
--- EXAMPLE: rew renTrans( "s" |-> int(3), "f" |-> int(4) , ( "s" |> "f" ) ) .


----------------------------------------------------------------------
--- helper functions for creating the variable prefix
----------------------------------------------------------------------
--- TODO: the rules for initiating an object should be changed such
--- that there always is a ".label" also`,' "this" should always be
--- defined - change the rules accordingly

    op label : Oid Nat -> Label [ctor ``format'' (o o)] .
    op toString : Label -> String .
    op toString : Oid -> String .
    op getThis : Subst -> String .
    op getLabel : Subst -> String .

    eq toString( label(ob(Q), F) ) = Q + "-" + string(F, 10) .
    eq toString(ob(Q) ) = Q .
    ceq getThis(S) = toString(S["this"]) if $hasMapping(S, "this") .
    eq getThis(S) = "global" [owise] .

    ceq getLabel(S) = toString(S[".label"]) if $hasMapping(S, ".label") .
    ceq getLabel(S) = toString(S["this"]) if $hasMapping(S, "this") .
    eq getLabel(S) = "nolabel" [owise] .


op replacementMap : Subst Subst -> TSubst .
op replacementMap : Subst String TSubst -> TSubst .

eq replacementMap(S, L) = replacementMap(S, getThis((L, S)), replacementMap(L, getLabel((L, S)), TnoSubst) ) .
eq replacementMap((  V1 |-> E1 , S ), Q, TS1) = replacementMap(S, Q, insert(V1, (Q + "." + V1), TS1) ) .
eq replacementMap( noSubst, Q, TS1) = TS1 .

---------------------------------------------------------------------
---  functions that perform the renaming
---------------------------------------------------------------------
--- TODO:  change to a single function with pattern matching
--- TODO:  move the examples to test cases

 op genRenameHelper : Subst String TSubst -> TSubst .
 op renameLHS : Subst String TSubst -> TSubst .
 op renameRHS : TSubst TSubst -> TSubst .
 op renTrans1 : Subst String TSubst -> TSubst .
 op renTrans : Subst Subst TSubst -> TSubst . 
 op renStmt1 : Subst String Stmt -> Stmt .
 op renStmt : Subst Subst Stmt -> Stmt .
 op renelist : TSubst ExprList -> ExprList .
 op renvlist : TSubst VidList -> VidList .
 op renExpr : Subst Subst Expr -> Expr .

--- generate a helper map to rename the variables
 eq genRenameHelper (noSubst, Q, TS1) = TS1 .
 eq genRenameHelper ((  V1 |-> E1 , S ), Q, TS1) = genRenameHelper( S, Q, insert(V1, (Q + V1), TS1) ) .

----------------------------------------------------------------------
--- rename variables in a list
----------------------------------------------------------------------
--- renameLHS( S, Q, TS1) = rename the LHS of TS1 by prepending Q if
--- the Vid is in the keyset of S.  Dont change the other keys.
 eq renameLHS( noSubst, Q, TS1 ) = TS1 .
 eq renameLHS( (  V1 |-> E1 , S ), Q, ( TS1, V1 |> E2) ) = renameLHS( S, Q, insert(  ( Q + V1  ) , E2, TS1 ) ) .
 eq renameLHS( (  V1 |-> E1 , S ), Q,  TS1 ) = renameLHS(S, Q, TS1)  [owise] .

--- renameRHS(TS1, TS2) = rename variables in the RHS of TS2 by
--- the replacemap in TS1.
 eq renameRHS( TS1,  ( Q |> E1, TS2) ) = insert( Q, replace(E1, TS1), renameRHS(TS1, TS2) ) .
 eq renameRHS( TS1, TnoSubst) = TnoSubst .

--- rename the variables in transitions
 eq renTrans1(S, Q, TS1) = renameRHS(genRenameHelper(S, Q, TnoSubst), renameLHS(S, Q, TS1) ) .
 eq renTrans1(noSubst, Q, TS1) = TS1 .
--- renTrans( S, Q, TS1) = rename the variables in TS1 according to the local and global variables.
 eq renTrans(S, L, TS1) = renTrans1(S, getThis(S)  + ".", renTrans1(L, getLabel((L,S)) + ".", TS1) ) .



----------------------------------------------------------------------
--- rename the variables in a statement (TODO check: only for pretty print?)
----------------------------------------------------------------------
 eq renStmt1(S, Q, assign(AL ; EL ) ) 
  = assign ( renvlist(genRenameHelper(S, Q, TnoSubst), AL) ; renelist(genRenameHelper(S, Q, TnoSubst), EL) ) .

 eq renStmt(S, L, assign( AL ; EL ) ) 
  = renStmt1( S, getThis(S) + ".", renStmt1(L, getLabel((L,S)) + ".", assign( AL ; EL ) ) ) .

--- ren the variables in an expressionlist TODO:special case of replace?
 eq renelist( TS1, emp ) = emp .
 eq renelist( TS1, ( E1 :: EL ) ) = ( replace(E1, TS1) :: renelist(TS1, EL ) ) .

--- ren the variables in an variableslist TODO:special case of replace?
 eq renvlist( TS1, noVid) = noVid .
 eq renvlist( TS1, (V1, AL) ) = ( replace(V1, TS1) , renvlist(TS1, AL) ) .

----------------------------------------------------------------------
--- rename the variables in an expression
----------------------------------------------------------------------

--- Example rew renExpr( "s" |-> int(2), "f" |-> int(3), "+" ( "s" :: "f" ) ) .
--- replace(E, genRenameHelper("f" |-> int(3), getLabel(("f" |-> int(3),"s" |-> int(2)))))
--- rew replace( "+" ("s" :: "f") , genRenameHelper("f" |-> int(3), getLabel(("f" |-> int(3),"s" |-> int(2))), TnoSubst)) .
--- rew renExpr( "mmax" |-> int(2), noSubst,  "&&"("<"("m" :: "mmax") :: "<"("-"("mfree" :: "t") :: "/"("m" :: "mrate"))) ) .
eq renExpr(S, L, E1) 
 = replace(replace(E1, genRenameHelper(L, getLabel((L,S)) + ".", TnoSubst)), 
               genRenameHelper(S, getThis( (L,S)) + ".", TnoSubst) ) .


var transstmt : Stmt .
vars trans : TSubst .
var E : Expr .
vars C CC : String .


----------------------------------------------------------------------
--- generate the Transition Relation of an assign statement
----------------------------------------------------------------------

--- compute the transition of an expression:
--- EXAMPLE genTrans(assign("x" ; "+" ("x" :: int(1) ) ) ) .
--- EXAMPLE appending two assignments: rew appendTrans( genTrans(assign("x" ; "+" ("x" :: int(1) ) ) ) , genTrans(assign("z" ; "x") )  ) .
op size : TSubst -> Nat .
eq size(TS1) = sizeR (TS1, 0) .

op sizeR : TSubst Nat -> Nat .
eq sizeR(TnoSubst, F ) = F .
eq sizeR((TS1, V1 |> E2), F) = sizeR(TS1, F + 1) .
 
op genTrans : Stmt -> TSubst .
eq genTrans( transstmt ) = genTransR ( transstmt , TnoSubst ) .

op genTransR : Stmt TSubst -> TSubst .
eq genTransR(assign( ((C @ CC), AL ) ; EL ) , trans ) = genTransR(assign ( (C, AL ) ; EL ), trans ) . --- get rid of the @
--- eq genTransR(assign( (V1, AL) ; emp ) , trans ) 
---    = V1 |> list(emp) . ---weird special case when an empty list is assigned
eq genTransR(assign( (V1, AL) ; (E1 :: EL) ) , trans ) 
   = genTransR ( assign( AL ; EL ) , insert (V1, E1, trans) ) .
eq genTransR(call(A ; E ; Q ; emp ), trans ) = trans .
eq genTransR(call(A ; E ; Q ; (E1 :: EL) ), trans ) 
   = genTransR(call(A ; E ; Q ; EL ), insert(string(size(trans),10), E1, trans ) ) .
eq genTransR(new(A ; CC ; emp ), trans) = trans .
eq genTransR(new(A ; CC ; (E1 :: EL) ), trans) 
   = genTransR(new(A ; CC ; EL), insert(string(size(trans), 10), E1, trans) ) .
eq genTransR(return( emp ), trans) = trans .
eq genTransR(return((E1 :: EL) ), trans ) 
   = genTransR(return( EL), insert( string(size(trans), 10), E1, trans ) ) .
eq genTransR(noStmt , trans ) = trans .

op getTrans : Stmt Subst Subst -> TSubst .
op getTrans : Stmt TSubst TSubst -> TSubst .
op getTrans : Stmt TSubst -> TSubst .

eq getTrans( transstmt, S, L) = getTrans (transstmt, replacementMap(S, L), TnoSubst ) .
eq getTrans( assign( (( C @ CC), AL) ; EL ) , TS1, TS2) = 
   getTrans( assign( replace(( C, AL), TS1) ; replace(EL, TS1) ), TS2) . --- get rid of @
eq getTrans( assign( AL ; EL ) , TS1, TS2) = 
   getTrans( assign( replace(AL , TS1) ; replace(EL, TS1) ), TS2) . 
eq getTrans( assign((V1, AL) ; (E1 :: EL)), TS2) = getTrans( assign(AL ; EL), insert(V1, E1, TS2) ) .
eq getTrans( noStmt, TS2) = TS2 .

endm
