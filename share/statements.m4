dnl Definition of creol statements.
dnl
dnl Copyright (c) 2007, 2008 by Marcel Kyas <kyas@ifi.uio.no>
dnl
dnl Do NOT edit this file.  This file may be overwritten.  It has been
dnl automatically generated from interpreter.m4 using m4.
dnl
dnl This program is free software; you can redistribute it and/or
dnl modify it under the terms of the GNU General Public License as
dnl published by the Free Software Foundation; either version 3 of the
dnl License, or (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl General Public License for more details.
dnl
dnl You should have received a copy of the GNU General Public License
dnl along with this program.  If not, see <http://www.gnu.org/licenses/>.
dnl
*** Creol Statements
***
*** The following module defines all elementary statements of Creol.
***
*** Colouring rules:  Statements from the programmer syntax are displayed
*** in blue.  Statements inserted by the compiler only are displayed in
*** cyan.  Statements inserted by the run-time system are displayed in
*** red.  It may indicate a problem if a red term appears in a configuration.

fmod CREOL-STATEMENT is

  protecting CREOL-DATA-VIDLIST .
  protecting CREOL-EXPRESSION .
  protecting CREOL-SUBST .
  protecting CREOL-CID .

  *** SuspStmt is a statement which can be suspended.  It includes
  *** await, [] and ||| (the later two defined in CREOL-STM-LIST.
  sorts Stmt SuspStmt .
  subsort SuspStmt < Stmt .

  op skip : -> Stmt [ctor `format' (b o)] .
  op commit : -> Stmt [ctor `format' (c o)] .
  op release : -> Stmt [ctor `format' (b o)] .
  op await_ : Expr -> SuspStmt [ctor `format' (b o d)] .
  op posit_ : Expr -> SuspStmt [ctor `format' (b o d)] .
  op assert_ : Expr -> Stmt [ctor `format' (b o d)] .
  op assign(_;_) : VidList ExprList -> Stmt [ctor `format' (b d o b o b o)] .
  op new(_;_;_) : Vid Cid ExprList -> Stmt [ctor `format' (b d o b o b o b o)] .
  op call(_;_;_;_) : Vid Expr String ExprList -> Stmt [ctor `format' (b d o b o b o b o b o)] . 
  op static(_;_;_;_;_) : Vid String Cid Cid ExprList -> Stmt [ctor `format' (b d o b o b o b o b o b o)] . 
  op multicast(_;_;_) : Expr String ExprList -> Stmt [ctor `format' (b d o b o b o b o)] .
  op get(_;_)  : Vid VidList -> Stmt [ctor `format' (b d o b o b o)] .
  op get(_;_)  : Label VidList -> Stmt [ctor ditto] .

  op return(_) : ExprList -> Stmt [ctor `format' (c d o c o)] .
  op free(_) : Vid -> Stmt [ctor `format' (c d o c o)] .
  op tailcall(_;_;_) : Expr String ExprList -> Stmt [ctor `format' (c d o c o c o c o)] .
  op statictail(_;_;_;_) : String Cid Cid ExprList -> Stmt [ctor `format' (c d o c o c o c o c o)] .

  op $cont_ : Label -> Stmt [ctor `format' (r o d)] .
  op $accept_ : Label -> Stmt [ctor `format' (r o d)] .
ifdef(`LOGGING',dnl
  op $bawait_ : Expr -> SuspStmt [ctor `format' (b o d)] .
  op $marker_ : String -> Stmt [ctor] .
  op $rmarker(_, _) : String String -> Stmt [ctor] .
)dnl

  --- Assertion Failure.
  --- This ``statement'' represents an assertion failure.  It 
  --- stops evaluation of the executing object at that point.
  op failure_ : Expr -> [Stmt] [ctor `format' (r! o d)] .

  --- Multiple Assignment.
  --- For the model checker the following will be evaluated as an
  --- equation and the old rule is not confluent.
  op $assign(_;_) : VidList DataList -> Stmt  [`format' (r d o r o r o)] .

  --- Multicast
  --- This ``statement'' emanates from the ordinary mutlicast statement
  --- after the argument and the target collection have been evaluated.
  --- It will generate the actual invocation messages.
  op $multicast(_;_;_) : Data String DataList -> Stmt [`format' (r d o r o r o r o)] .

endfm

view Stmt from TRIV to CREOL-STATEMENT is
   sort Elt to Stmt .
endv



*** Specification of compound statements.
***
fmod CREOL-STM-LIST is
  protecting CREOL-STATEMENT .                
  protecting LIST{Stmt} * (sort List{Stmt} to StmtList,
                          sort NeList{Stmt} to NeStmtList,
			  op nil : -> List{Stmt} to noStmt,
			  op __ : List{Stmt} List{Stmt} -> List{Stmt} to _;_ [`format' (d r o d)]) .
ifdef(`LOGGING',dnl
*** Variable mapping that allows symbolic values
  extending MAP{Vid`,' Expr} * (sort Map{Vid`,'Expr} to TSubst`,'
                              sort Entry{Vid`,'Expr} to TBinding`,'
                              op empty : -> Map{Vid`,'Expr} to TnoSubst`,'
                              op _ |-> _  : Vid Expr -> Map{Vid`,'Expr} to _ |> _ [format (nsso r! o o)] `,'
                              op undefined : -> [Expr] to undeftrans ) .
)
  op if_th_el_fi : Expr StmtList StmtList -> Stmt [ctor `format' (b o b o b o b o)] . 
  op while_do_od : Expr StmtList -> Stmt [ctor `format' (b o b o b o)] .
  op _[]_  : StmtList StmtList -> SuspStmt [ctor comm assoc prec 45 `format' (d b d o d)] .
ifdef(`WITH_MERGE',
`  op _|||_ : StmtList StmtList -> SuspStmt [ctor comm assoc prec 47 `format' (d b o d)] .
  op _MERGER_  : StmtList StmtList -> Stmt [ctor assoc `format' (d r o d)] .
')

  var SL : StmtList .
  var E : Expr .

  --- optimize some statements.
  eq noStmt [] SL = SL .
ifdef(`WITH_MERGE',
  eq noStmt ||| SL = SL .
  eq noStmt MERGER SL = SL .
  eq SL MERGER noStmt = SL .
')
  --- Optimize assignments.  This way we save reducing a skip.  Also note
  --- that the empty assignment is /not/ programmer syntax, it is inserted
  --- during run-time.
  eq assign(noVid ; emp) = noStmt .
  eq $assign(noVid ; emp) = noStmt .

endfm
