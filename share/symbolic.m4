dnl A simple term replacement system for Creol.
dnl
dnl Copyright (c) 2009 by Andreas Griesmayer <gismo@kangaroo.at>
dnl   and Marcel Kyas <kyas@ifi.uio.no>
dnl
dnl Do NOT edit this file.  This file may be overwritten.  It has been
dnl automatically generated from interpreter.m4 using m4.
dnl
dnl This program is free software; you can redistribute it and/or
dnl modify it under the terms of the GNU General Public License as
dnl published by the Free Software Foundation; either version 3 of the
dnl License, or (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl General Public License for more details.
dnl
dnl You should have received a copy of the GNU General Public License
dnl along with this program.  If not, see <http://www.gnu.org/licenses/>.
dnl
mod `CREOL-SYMBOLIC' is

    protecting CREOL-REPLACE .

------------------------------------------------------------------------
--- give variables a unique name
--- --------------------------------------------------------------------
--- The log is a serialized version of Creol.  Statements from
--- different methods and objects are interleaved and might operate on
--- variables that are actually different`,' but have the same name.  To
--- avoid the necessity to consider the scope at the execution of
--- every statement`,' the variables are renamed to a unique name`,' by
--- prefixim them with an identifyer.  The object ID is used for
--- global variables`,' and the label for local variables.

--- examples
--- EXAMPLE rew renameLHS ( ( "s" |-> int(4), "d" |-> int(4) ) , "pre", ( "s" |> "sd", "ff" |> "fs") ) .
--- example rew renameRHS( genRenameHelper( ("sd" |-> int(0) ), "pre" ) , ( "s" |> "+"( "sd" :: int(2) ), "ff" |> "fs") ) .
--- EXAMPLE: rew renTrans( "s" |-> int(3), "f" |-> int(4) , ( "s" |> "f" ) ) .
--- Example rew renExpr( "s" |-> int(2), "f" |-> int(3), "+" ( "s" :: "f" ) ) .
--- EXAMPLE genTrans(assign("x" ; "+" ("x" :: int(1) ) ) ) .
--- EXAMPLE appending two assignments: rew appendTrans( genTrans(assign("x" ; "+" ("x" :: int(1) ) ) ) , genTrans(assign("z" ; "x") )  ) .

    vars TS1 TS2 TS3 : TSubst .
    var V1 : Vid .
    var S L : Subst .
    var C CC Q : String . 
    vars E1 E2 : Expr .
    var F : Nat .
    var O : Oid .
    var AL : VidList .
    var EL : ExprList .
    var transstmt : Stmt .

----------------------------------------------------------------------
--- helper functions for creating the variable prefix
----------------------------------------------------------------------
--- TODO: the rules for initiating an object should be changed such
--- that there always is a ".label" also`,' "this" should always be
--- defined - change the rules accordingly

    op label : Oid Nat -> Label [ctor ``format'' (o o)] .
    op toString : Label -> String .
    op toString : Oid -> String .
    op getThis : Subst -> String .
    op getLabel : Subst -> String .
    op size : TSubst -> Nat .
    op size : TSubst Nat -> Nat .


    op getTrans : Stmt -> TSubst .
    op getTrans : Stmt Subst Subst -> TSubst .
    op getTrans : Stmt TSubst TSubst -> TSubst .
    op getTrans : Stmt TSubst -> TSubst .
    op renStmt : Stmt Subst Subst -> Stmt .
    op renStmt : Stmt TSubst -> Stmt .
    op renExpr : Subst Subst Expr -> Expr .
    op replacementMap : Subst Subst -> TSubst .
    op replacementMap : Subst String TSubst -> TSubst .

    eq toString( label(ob(Q), F) ) = Q + "-" + string(F, 10) .
    eq toString(ob(Q) ) = Q .
    ceq getThis(S) = toString(S["this"]) if $hasMapping(S, "this") .
    eq getThis(S) = "global" [owise] .

    ceq getLabel(S) = toString(S[".label"]) if $hasMapping(S, ".label") .
    ceq getLabel(S) = toString(S["this"]) if $hasMapping(S, "this") .
    eq getLabel(S) = "nolabel" [owise] .

    eq size(TS1) = size (TS1, 0) .
    eq size(TnoSubst, F ) = F .
    eq size((TS1, V1 |> E2), F) = size(TS1, F + 1) .

    eq replacementMap(S, L) = replacementMap(S, getThis((L, S)), replacementMap(L, getLabel((L, S)), TnoSubst) ) .
    eq replacementMap((  V1 |-> E1 , S ), Q, TS1) = replacementMap(S, Q, insert(V1, (Q + "." + V1), TS1) ) .
    eq replacementMap( noSubst, Q, TS1) = TS1 .

    eq renExpr(S, L, E1) = replace(E1, replacementMap(S, L) ) .
    eq renStmt( transstmt, S, L) = renStmt( transstmt, replacementMap(S, L) ) .
    eq renStmt( assign( AL ; EL), TS1) = assign(replace(AL, TS1); replace(EL, TS1) ) .

    eq getTrans( transstmt) = getTrans(transstmt, noSubst, noSubst) .
    eq getTrans( transstmt, S, L) = getTrans (transstmt, replacementMap(S, L), TnoSubst ) .
    eq getTrans( assign( (( C @ CC), AL) ; EL ) , TS1, TS2)
     = getTrans( assign( replace(( C, AL), TS1) ; replace(EL, TS1) ), TS2) . --- get rid of @
    eq getTrans( assign( AL ; EL ) , TS1, TS2)
     = getTrans( assign( replace(AL , TS1) ; replace(EL, TS1) ), TS2) . 
    eq getTrans( assign((V1, AL) ; (E1 :: EL)), TS2) = getTrans( assign(AL ; EL), insert(V1, E1, TS2) ) .
    eq getTrans( call(C ; E1 ; Q ; EL ), TS1, TS2) = getTrans( call(C ; E1 ; Q ; replace(EL, TS1) ), TS2 ) .
    eq getTrans( call(C ; E1 ; Q ; (E2 :: EL) ), TS2)
     = getTrans( call(C ; E1 ; Q ; EL ), insert(string(size(TS2),10), E2, TS2 ) ) .
    eq getTrans( call(C ; E1 ; Q ; emp ), TS2 ) = TS2 .
    eq getTrans( new(C ; CC ; EL ), TS1, TS2 ) = getTrans( new(C ; CC ; replace(EL, TS1) ), TS2 ) .
    eq getTrans( new(C ; CC ; (E1 :: EL) ), TS2) 
     = getTrans( new(C ; CC ; EL), insert(string(size(TS2), 10), E1, TS2) ) .
    eq getTrans( new(C ; CC ; emp ), TS2) = TS2 .
    eq getTrans( return( EL ), TS1, TS2 ) = getTrans( return(replace(EL, TS1)), TS2 ) .
    eq getTrans( return((E1 :: EL) ), TS2 ) 
       = getTrans(return( EL), insert( string(size(TS2), 10), E1, TS2 ) ) .
    eq getTrans( return( emp ), TS2) = TS2 .
    eq getTrans( noStmt, TS2) = TS2 .

---  delete an entry from a map
op delete : Vid TSubst -> TSubst .
eq delete(C , (TS1, C |> E1)) =
   if $hasMapping( TS1 , C) then delete(C, TS1)
   else TS1
   fi .

--- convert a Subst to TSubst
op toTrans : Subst -> TSubst .
eq toTrans(noSubst) = TnoSubst .
eq toTrans( ( V1 |-> E1, S) ) = insert( V1, E1, toTrans(S) ) .

--- combine assignment transitions
op getParamsR : TSubst Nat ExprList -> ExprList .
eq getParamsR( TnoSubst , F, EL) = EL .
eq getParamsR( TS1 , F , EL ) = getParamsR( ( delete(string(F, 10) , TS1) ) , (F + 1) , (EL :: (TS1[ string(F, 10) ])) ) .

op getParams : TSubst -> ExprList .
eq getParams( TS1 ) = getParamsR( TS1, 0, emp ) .

--- insertPassing: insert params to pass to called methods or new
--- instances.  if the list of params is empty`,' the call is ignored
op insertPassing : Vid ExprList TSubst -> TSubst .
eq insertPassing( V1 , emp , TS1 ) = TS1 .
eq insertPassing( V1 , EL , TS1 ) = insert(V1, list(EL), TS1) .


--- insertValues (TS1, TS2):  for each RHS in TS2`,' replace the variables by the expressions defined in TS1
--- EXAMPLE: rew insertValues(  ("y" |> "z" ) , ("x" |> "+" ("y" :: int(1) ) )) .
---          rew insertValues(  ("y" |> "z", "f" |> int(1) ) , ("x" |> "+" ("y" :: "f" ) )) .
--- TODO can this be put in an other function?
op insertValues : TSubst TSubst -> TSubst .
eq insertValues( TS1, TS2 ) = insertValuesR( TS1, TS2, TnoSubst) .

op insertValuesR : TSubst TSubst TSubst -> TSubst .  
eq insertValuesR( TS1, TnoSubst, TS3 ) = TS3 .
eq insertValuesR( TS1, (V1 |> E2, TS2), TS3 ) = insertValuesR( TS1, TS2, insert( V1, replace (E2, TS1), TS3) ) .


--- insertTrans(T1, T2): insert all variables from T1 into T2`,' overwriting values in T2
--- EXAMPLE: rew insertTrans( ( "x" |> int(4) ), ("x" |> int(5), "y" |> int (4) ) ) .
op insertTrans : TSubst TSubst -> TSubst .
eq insertTrans( TnoSubst, TS2) = TS2 .
eq insertTrans( (V1 |> E1, TS1), TS2) = insertTrans( TS1, insert (V1, E1, TS2) ) .


--- appendTrans(TS1, TS2) :  append TS2 to TS1.  first`,' the variables 
--- in TS2 are replaced by the expressions in TS1`,' then the definitions 
--- from TS2 are taken and put into TS1`,' overwriting the assignments 
--- if there are new ones in TS2
--- EXAMPLE rew appendTrans( ( "x" |> "+"("x" :: int(1))), ("z" |> "x") ) .
---         rew appendTrans( ( "x" |> "+"("x" :: int(1))), ("z" |> "x", "x" |> int(3) ) ) .
--- NOTE:  variables on the LHS give the new values`,' while variables 
---        on the RHS are the values at the start of execution - 
--- like a normal assign statement
op appendTrans : TSubst TSubst -> TSubst .
eq appendTrans ( TS1, TS2 ) = insertTrans(insertValues( TS1, TS2 ), TS1 ) .



endm
