dnl A simple term replacement system for Creol.
dnl
dnl Copyright (c) 2009 by Andreas Griesmayer <gismo@kangaroo.at>
dnl   and Marcel Kyas <kyas@ifi.uio.no>
dnl
dnl Do NOT edit this file.  This file may be overwritten.  It has been
dnl automatically generated from interpreter.m4 using m4.
dnl
dnl This program is free software; you can redistribute it and/or
dnl modify it under the terms of the GNU General Public License as
dnl published by the Free Software Foundation; either version 3 of the
dnl License, or (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl General Public License for more details.
dnl
dnl You should have received a copy of the GNU General Public License
dnl along with this program.  If not, see <http://www.gnu.org/licenses/>.
dnl
mod `CREOL-SYMBOLIC' is

    protecting CREOL-REPLACE .

------------------------------------------------------------------------
--- compute and work with symbolic transition relations
------------------------------------------------------------------------
--- a transition relation shows how the variables change by execution
--- of a statement.  The transitionrelation is stored in a map similar
--- to an assignment statement - a form that makes backward reasoning
--- easy.  The key is the next state variable`,' the value an expression
--- that describes the state change in therm of the current
--- variables. e.g. for two variables in the writing of parallel
--- assignments: 
--- x'`,' y' = f(x, y)`,' g(x,y) ; 
--- x"`,' y" = f'(x', y')`,' g'(x', y') 
--- this sequence of statements can be combined by replacing x' and y'
---  - the "middle" variables - by the expressions f and g to
--- x"`,' y" = f'(f(x, y), g(x, y))`,' g'(f(x, y), g(x, y))
---
--- initial states that fulfill a condition c(x", y") can easily be
--- computed by replacing x" and y" by their respective expressions in
--- terms of x and y
---
------------------------------------------------------------------------
--- give variables a unique name
--- --------------------------------------------------------------------
--- The log is a serialized version of Creol.  Statements from
--- different methods and objects are interleaved and might operate on
--- variables that are actually different`,' but have the same name.  To
--- avoid the necessity to consider the scope at the execution of
--- every statement`,' the variables are renamed to a unique name`,' by
--- prefixing them with an identifyer.  The object ID is used for
--- global variables`,' and the label for local variables.


------------
--- Declarations
------------

    vars TS1 TS2 TS3 : TSubst .
    var V1 : Vid .
    var S L : Subst .
    var C CC Q : String . 
    vars E1 E2 : Expr .
    var F : Nat .
    var O : Oid .
    var AL : VidList .
    var EL : ExprList .
    var transstmt : Stmt .

--- generate Transitions with unique variable names
    op getTrans : Stmt -> TSubst .
    op getTrans : Stmt Subst Subst -> TSubst .
    op getTrans : Stmt TSubst TSubst -> TSubst .
    op getTrans : Stmt TSubst -> TSubst .
    op renStmt : Stmt Subst Subst -> Stmt .
    op renStmt : Stmt TSubst -> Stmt .
    op renExpr : Subst Subst Expr -> Expr .
    op replacementMap : Subst Subst -> TSubst .
    op replacementMap : Subst String TSubst -> TSubst .

--- append and merge transitions
    op appendTrans : TSubst TSubst -> TSubst .
    op replaceMiddle : TSubst TSubst -> TSubst .
    op replaceMiddle : TSubst TSubst TSubst -> TSubst .  
    op mergeTrans : TSubst TSubst -> TSubst .

--- helper functions
    op label : Oid Nat -> Label [ctor ``format'' (o o)] .
    op toString : Label -> String .
    op toString : Oid -> String .
    op getThis : Subst -> String .
    op getLabel : Subst -> String .
    op size : TSubst -> Nat .
    op size : TSubst Nat -> Nat .
    op delete : Vid TSubst -> TSubst .
    op toTrans : Subst -> TSubst .
    op getParamsR : TSubst Nat ExprList -> ExprList .
    op getParams : TSubst -> ExprList .
    op insertPassing : Vid ExprList TSubst -> TSubst .

------------
--- Equations
------------
    eq getTrans( transstmt) = getTrans(transstmt, noSubst, noSubst) .
    eq getTrans( transstmt, S, L) = getTrans (transstmt, replacementMap(S, L), TnoSubst ) .
    eq getTrans( assign( (( C @ CC), AL) ; EL ) , TS1, TS2)
     = getTrans( assign( replace(( C, AL), TS1) ; replace(EL, TS1) ), TS2) . --- get rid of @
    eq getTrans( assign( AL ; EL ) , TS1, TS2)
     = getTrans( assign( replace(AL , TS1) ; replace(EL, TS1) ), TS2) . 
    eq getTrans( assign((V1, AL) ; (E1 :: EL)), TS2) = getTrans( assign(AL ; EL), insert(V1, E1, TS2) ) .
    eq getTrans( call(C ; E1 ; Q ; EL ), TS1, TS2) = getTrans( call(C ; E1 ; Q ; replace(EL, TS1) ), TS2 ) .
    eq getTrans( call(C ; E1 ; Q ; (E2 :: EL) ), TS2)
     = getTrans( call(C ; E1 ; Q ; EL ), insert(string(size(TS2),10), E2, TS2 ) ) .
    eq getTrans( call(C ; E1 ; Q ; emp ), TS2 ) = TS2 .
    eq getTrans( new(C ; CC ; EL ), TS1, TS2 ) = getTrans( new(C ; CC ; replace(EL, TS1) ), TS2 ) .
    eq getTrans( new(C ; CC ; (E1 :: EL) ), TS2) 
     = getTrans( new(C ; CC ; EL), insert(string(size(TS2), 10), E1, TS2) ) .
    eq getTrans( new(C ; CC ; emp ), TS2) = TS2 .
    eq getTrans( return( EL ), TS1, TS2 ) = getTrans( return(replace(EL, TS1)), TS2 ) .
    eq getTrans( return((E1 :: EL) ), TS2 ) 
     = getTrans(return( EL), insert( string(size(TS2), 10), E1, TS2 ) ) .
    eq getTrans( return( emp ), TS2) = TS2 .
    eq getTrans( noStmt, TS2) = TS2 .

    eq renExpr(S, L, E1) = replace(E1, replacementMap(S, L) ) .
    eq renStmt( transstmt, S, L) = renStmt( transstmt, replacementMap(S, L) ) .
    eq renStmt( assign( AL ; EL), TS1) = assign(replace(AL, TS1); replace(EL, TS1) ) .

    eq replacementMap(S, L) = replacementMap(S, getThis((L, S)), replacementMap(L, getLabel((L, S)), TnoSubst) ) .
    eq replacementMap((  V1 |-> E1 , S ), Q, TS1) = replacementMap(S, Q, insert(V1, (Q + "." + V1), TS1) ) .
    eq replacementMap( noSubst, Q, TS1) = TS1 .


--- appendTrans(TS1, TS2) : append TS2 to TS1 by replacing the
--- variables in TS2 by the expressions given in TS1.  Variables that
--- are not redefined in TS2 are taken from TS1.
    eq appendTrans ( TS1, TS2 ) = mergeTrans(TS1, replaceMiddle( TS2, TS1 ) ) .

    eq replaceMiddle( TS1, TS2 ) = replaceMiddle( TS1, TS2, TnoSubst) .
    eq replaceMiddle( TnoSubst, TS2, TS3 ) = TS3 .
    eq replaceMiddle( (V1 |> E1, TS1), TS2, TS3 ) = replaceMiddle( TS1, TS2, insert( V1, replace (E1, TS2), TS3) ) .

--- insertTrans(T1, T2): insert all variables from T2 into T1`,' overwriting values in T1
    eq mergeTrans( TS1, TnoSubst ) = TS1 .
    eq mergeTrans( TS1, (V1 |> E1, TS2)) = mergeTrans( insert (V1, E1, TS1), TS2 ) .

    eq  toString(label(ob(Q), F) ) = Q + "-" + string(F, 10) .
    eq  toString(ob(Q) ) = Q .
    ceq getThis(S) = toString(S["this"]) if $hasMapping(S, "this") .
    eq  getThis(S) = "global" [owise] .
    ceq getLabel(S) = toString(S[".label"]) if $hasMapping(S, ".label") .
    ceq getLabel(S) = toString(S["this"]) if $hasMapping(S, "this") .
    eq  getLabel(S) = "nolabel" [owise] .

    eq size(TS1) = size (TS1, 0) .
    eq size(TnoSubst, F ) = F .
    eq size((TS1, V1 |> E2), F) = size(TS1, F + 1) .

---  delete the key C from a map (must exist! - deadlock otherwise)
    eq delete(C , (TS1, C |> E1)) = TS1 .

--- convert a Subst to TSubst
    eq toTrans(noSubst) = TnoSubst .
    eq toTrans( ( V1 |-> E1, S) ) = insert( V1, E1, toTrans(S) ) .

--- combine assignment transitions
    eq getParamsR( TnoSubst , F, EL) = EL .
    eq getParamsR( TS1 , F , EL ) 
     = getParamsR( ( delete(string(F, 10) , TS1) ) , (F + 1) , (EL :: (TS1[ string(F, 10) ])) ) .
    eq getParams( TS1 ) = getParamsR( TS1, 0, emp ) .

--- insertPassing: insert params to pass to called methods or new
--- instances.  if the list of params is empty`,' the call is ignored
    eq insertPassing( V1 , emp , TS1 ) = TS1 .
    eq insertPassing( V1 , EL , TS1 ) = insert(V1, list(EL), TS1) .

--- examples TODO: change examples to test cases
--- EXAMPLE rew renameLHS ( ( "s" |-> int(4), "d" |-> int(4) ) , "pre", ( "s" |> "sd", "ff" |> "fs") ) .
--- example rew renameRHS( genRenameHelper( ("sd" |-> int(0) ), "pre" ) , ( "s" |> "+"( "sd" :: int(2) ), "ff" |> "fs") ) .
--- EXAMPLE: rew renTrans( "s" |-> int(3), "f" |-> int(4) , ( "s" |> "f" ) ) .
--- Example rew renExpr( "s" |-> int(2), "f" |-> int(3), "+" ( "s" :: "f" ) ) .
--- EXAMPLE genTrans(assign("x" ; "+" ("x" :: int(1) ) ) ) .
--- EXAMPLE appending two assignments: rew appendTrans( genTrans(assign("x" ; "+" ("x" :: int(1) ) ) ) , genTrans(assign("z" ; "x") )  ) .
--- EXAMPLE: rew insertValues(  ("y" |> "z" ) , ("x" |> "+" ("y" :: int(1) ) )) .
---          rew insertValues(  ("y" |> "z", "f" |> int(1) ) , ("x" |> "+" ("y" :: "f" ) )) .
--- EXAMPLE rew appendTrans( ( "x" |> "+"("x" :: int(1))), ("z" |> "x") ) .
---         rew appendTrans( ( "x" |> "+"("x" :: int(1))), ("z" |> "x", "x" |> int(3) ) ) .
--- EXAMPLE: rew insertTrans( ( "x" |> int(4) ), ("x" |> int(5), "y" |> int (4) ) ) .

endm
